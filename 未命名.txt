中文回答，我需要用react作为前端，django作为后端实现这样的项目，js的前端很简单，就是这样的，用户在搜索框输入相关的关键字，然后组件渲染发送到django所在的后端

说实话我现在还不是特别理解django的这个结构，这个框架，解释这里的代码，django的backend和api的两个文件夹分别都是干什么的，前端的search请求发送过来后，在后端django的页面发生的事情的流程是什么样的


Projet final – CHOIX A. Moteur de recherche d’une bibliotheque. `
BM Bui-Xuan
Application web/mobile : Une application web/mobile se distingue d’une page web par ses fonctionnalites avec ´
interaction utilisateur alors qu’une page web est par definition statique. Cette interaction peut ´ etre explicite dans le sens ˆ
ou le r ` esultat retourn ´ e par l’application est en r ´ eponse imm ´ ediate ´ a une action que l’utilisateur vient d’effectuer. Dans le `
cas d’une fonctionnalite d ´ eriv ´ ee d’une action, ou des actions plus anciennes, on parlera de fonctionnalit ´ e implicite. ´
Bibliotheque et moteur de recherche : ` Dans ce projet, on appelle bibliotheque toute base de donn ` ees de taille ´
assez consequente de documents textuels. Un tel exemple est la base de Gutenberg disponible ´ a l’adresse suivante : `
http://www.gutenberg.org/ ou les documents sont pr ` esent ´ es sous diff ´ erentes formes, dont le format textuel. A l’instar de ´
la base Gutenberg, une bibliotheque peut contenir des dizaines de milliers de documents, rendant une recherche manuelle `
impossible. Un moteur de recherche dans une base de donnees est une application web/mobile permettant ´ a l’utilisateur `
d’acceder plus rapidement ´ a un document textuel par recherche de mot-clef, ou par historique de recherche en lien avec `
ce document (systeme de ` best-seller, de suggestion de publicite cibl ´ ee, de favoris utilisateur, et cetera). ´
Analyse de pertinence et analyse de performance : La pertinence d’un moteur de recherche est un critere subjectif `
determin ´ e´ a la suite de test utilisateur. En revanche, la performance d’un moteur de recherche est un crit ` ere objectif `
mesurable par des tests de charge sur differentes volumes de donn ´ ees. ´
1 L’enonc ´ e du projet final – CHOIX A ´
ATTENTION : Il est obligatoire d’indiquer a la premi ` ere page du rapport le “CHOIX A’ dans le rendu de projet. `
Il s’agit de proposer une application web/mobile de moteur de recherche de document dans une bibliotheque de livres `
sous format textuel. Pour cela, la premiere ` etape est de s’occuper de la couche ´ data du projet, i.e. la construction d’une
bibliotheque personnelle de livres, stock ` es sous forme de documents textuels. La taille minimum de la biblioth ´ eque `
doit etre ˆ 1664 livres. La taille minimum de chaque livre doit etre ˆ 10000 (dix mille) mots. Dans un second temps, il
s’agit de construire une application web/mobile (couches serveur et client) afin de munir sa bibliotheque d’un moteur de `
recherche. Chaque groupe est libre de determiner la pr ´ esentation ´ frontend et les userstory de son application, cependant,
les fonctionnalites principales de l’application doivent obligatoirement comprendre : ´
— Une fonctionnalite explicite de “Recherche” : ´ Recherche de livre par mot-clef. A la suite d’une entree texte ´ S
de l’utilisateur, l’application retourne la liste de tous les documents textuels dont la table de l’indexage contient la
chaˆıne de caracteres ` S.
— Une fonctionnalite explicite de “Recherche avanc ´ ee” : ´ Recherche dite “avancee” de livre par RegEx. A la suite ´
d’une entree texte ´ RegEx de l’utilisateur, l’application retourne : soit la liste de tous les documents textuels dont
la table de l’indexage contient une chaˆıne de caracteres ` S qui verifie l’expression r ´ eguli ´ ere ` RegEx; soit la liste
de tous les documents textuels dont le contenu textuel contient une chaˆıne de caracteres ` S qui verifie l’expression ´
reguli ´ ere ` RegEx (attention a la d ` egradation en performance). ´
— Une fonctionnalite implicite de classement : ´ Classement des reponses des deux fonctionnalit ´ es de recherche ´
prec´ edentes. A la suite d’une r ´ eponse ´ a la fonctionnalit ` e recherche, l’application retourne la liste des documents ´
triee par un certain crit ´ ere de pertinence : par nombre d’occurrences du mot-clef dans le document; par indice de `
centralite d ´ ecroissant dans le graphe de Jaccard, et cetera. Le crit ´ ere de centralit ` e est laiss ´ e libre ´ a chaque groupe `
d’interpreter. Cependant, il est obligatoire d’utiliser au moins un crit ´ ere parmi les trois indices vu en cours, ` a savoir `
15 septembre 2024
DAAR Projet final. CHOIX A – page 2/3
closeness, betweenness, ou pagerank. Concernant l’indice de centralite utilis ´ e, il est ´ egalement important de bien ´
le decrire dans le rapport. On veillera en particulier ´ a expliciter la d ` efinition, le calcul, ainsi que le r ´ esultat de cet ´
indice sur des extraits pertinents de quelques livres parmi les > 1664 livres presents dans la base de donn ´ ees. ´
— Une fonctionnalite implicite de suggestion : ´ Suggestion de reponses similaires ´ a la derni ` ere recherche. A la suite `
d’une reponse ´ a la fonctionnalit ` e recherche, l’application retourne ´ egalement : soit la liste des sommets dans le ´
graphe de Jaccard qui sont voisins avec les deux ou trois documents textuels les plus pertinents qui contiennent le
mot-clef; soit la liste des documents textuels les plus choisis (les plus cliques´ par d’autres utilisateurs) parmi les
sommets dans le graphe de Jaccard qui sont voisins avec les deux ou trois documents textuels les plus pertinents qui
contiennent le mot-clef; soit une autre liste suivant une strategie sp ´ ecifique qu’on expliquera bien dans le rapport. ´
Le rendu de ce projet est avant tout une application web/mobile. Il est donc important lors de la demonstration (cf. ´
presentation orale ou vid ´ eo pitch d ´ ecrite ci-dessous) que l’application web/mobile en question fonctionnent sur plusieurs ´
machines clientes en meme temps (laptops, smartphones, etc). ˆ
Un effort particulier doit etre mis sur la phase de test, la r ˆ edaction du rapport, et la pr ´ esentation orale du projet. Il y ´
aura ainsi trois notations distinctes pour le rendu de ce projet : une note pour la realisation ( ´ ≈ 30% de la note totale du
projet); une note pour le rapport (≈ 40%); et une note pour la presentation orale du projet ( ´ ≈ 30%).
Rapport : On veillera a expliciter les points suivants, pour chaque algorithme impl ` ement ´ e (y compris les algorithmes ´
decrits pendant les s ´ eances de cours tels de ceux dans le livre Aho-Ullman, algorithme KMP, ceux de Jaccard, ´ closeness,
betweenness ou pagerank) :
— definition du probl ´ eme et la structure de donn ` ees utilis ´ ee. ´
— analyse et presentation th ´ eorique des algorithmes connus dans la litt ´ erature. ´
— argumentation concise appuyant toute appreciation, am ´ elioration, ou critique ´ a propos de ces algorithmes existants `
dans la litterature. ´
— partie test : methode d’obtention des ´ testbeds. En particulier, il est important de citer la provenance des fichiers
sources, e.g. pour les documents textuels.
— test de performance : mieux vaut privilegier les courbes, diagrammes b ´ aton (moyenne + ˆ ecart type) et diagrammes ´
de frequence, plut ´ ot qu’exhiber les colonnes de chiffre sans fins... ˆ
— une discussion sur les resultats de test de performance est toujours la tr ´ es bienvenue. `
— presenter ´ egalement les tests d’utilisateur et test de pertinence, s’ils ont eu lieu. ´
— conclusion et perspectives sur ce probleme de moteur de recherche de biblioth ` eque. `
Il est prudent d’avoir entre 10 et 15 pages pour un rapport avec un contenu moyen. Le nombre de pages recommande´
pour ce rapport est 12 pages. Il convient de bien respecter cette limitation : les pages 16+ ne seront pas lues !

import React, { useEffect, useState } from "react";
import { useLocation } from "react-router-dom";
import BookCard from "../components/BookCard";

function useQuery() {
  return new URLSearchParams(useLocation().search);
}

function SearchResults() {
  const query = useQuery().get("q");
  const [books, setBooks] = useState([]);
  const [error, setError] = useState("");

  useEffect(() => {
    if (query) {
      const fetchBooks = async () => {
        setError("");  
        setBooks([]); 
        
        const encodedQuery = encodeURIComponent(query);
        const url = `http://127.0.0.1:8000/api/search-books/?q=${encodedQuery}`;

        try {
          const response = await fetch(url);
          const data = await response.json();

          if (response.ok) {
            setBooks(data);  // Met à jour la liste des livres
          } else {
            setBooks([]);
            setError(data.error || "Aucun livre trouvé.");
          }
        } catch (err) {
          console.error("Erreur :", err);
          setError("Problème de connexion avec le serveur.");
        }
      };

      fetchBooks();
    }
  }, [query]);

  return (
    <div className="container py-10">
      <h1 className="text-2xl font-bold">Résultats pour "{query}"</h1>

      {error && (
        <p className="text-center text-red-500 mt-6">
          {error}
        </p>
      )}

      {books.length === 0 && !error && (
        <p className="text-center text-gray-500 mt-6">
          Aucun livre trouvé pour "<span className="font-bold">{query}</span>". <br />
          Essayez un autre mot-clé ou une variante !
        </p>
      )}

      <div className="grid grid-cols-3 gap-6 mt-6">
        {books.map((book, index) => (
          <BookCard key={index} book={book} />
        ))}
      </div>
    </div>
  );
}

export default SearchResults;

from django.urls import path
from .views import fetch_books_from_gutendex, rank_books, regex_search_books, search_books, suggest_books

urlpatterns = [
    path('gutendex/', fetch_books_from_gutendex, name="fetch-books"),
    #path('search-books/', search_books, name='search-books'),  
    path("search-books/", search_books, name="search-books"),
    path("regex-search-books/", regex_search_books, name="regex-search-books"),
    path('rank/', rank_books, name="rank-books"),
    path('suggest/', suggest_books, name="suggest-books"),
]


import requests
from django.http import JsonResponse
from .models import Book

from django.shortcuts import get_list_or_404
from django.db.models import Q

import re

import networkx as nx
import numpy as np


""" ----------------- Récupérer des livres depuis Gutendex API ----------------- """

"""def fetch_books_from_gutendex(request):
    url = "https://gutendex.com/books/"
    response = requests.get(url)
    
    if response.status_code == 200:
        books_data = response.json()["results"]
        for book in books_data:
            Book.objects.get_or_create(
                title=book["title"],
                author=", ".join([a["name"] for a in book.get("authors", [])]),  # ← Fix ici
                language=", ".join(book["languages"]),
                download_count=book["download_count"],
                cover_url=book["formats"].get("image/jpeg", "")
            )

        return JsonResponse(books_data, safe=False)

    return JsonResponse({"error": "Failed to fetch books"}, status=500)"""

def fetch_books_from_gutendex(request):
    base_url = "https://gutendex.com/books/"
    count = 0

    while base_url:
        response = requests.get(base_url)
        if response.status_code != 200:
            return JsonResponse({"error": "Erreur lors de la récupération des livres"}, status=500)

        data = response.json()
        books_data = data["results"]

        for book in books_data:
            authors = ", ".join([a["name"] for a in book.get("authors", [])])
            languages = ", ".join(book.get("languages", []))
            download_count = book.get("download_count", 0)
            cover_url = book["formats"].get("image/jpeg", "")
            
            Book.objects.get_or_create(
                title=book["title"],
                author=authors,
                language=languages,
                download_count=download_count,
                cover_url=cover_url
            )
            count += 1

        base_url = data.get("next")

    return JsonResponse({"message": f"{count} livres importés"}, safe=False)


""" ----------------- Recherche simple par mot-clé -----------------"""

def search_books(request):
    query = request.GET.get("q", "")
    
    if query:
        books = Book.objects.filter(Q(title__icontains=query) | Q(author__icontains=query))
        data = list(books.values())
        return JsonResponse(data, safe=False)
    
    return JsonResponse({"error": "No books found"}, status=404)

""" ---------------- Recherche avancée par expression régulière ----------------- """

def regex_search_books(request):
    regex = request.GET.get("regex", "")
    
    if regex:
        books = Book.objects.all()
        matched_books = [book for book in books if re.search(regex, book.title, re.IGNORECASE)]
        data = [{"title": b.title, "author": b.author} for b in matched_books]
        return JsonResponse(data, safe=False)
    
    return JsonResponse({"error": "No books found"}, status=404)

"""def regex_search_books(request):
    regex = request.GET.get("regex", "")
    
    if not regex:
        return JsonResponse({"error": "Expression vide"}, status=400)

    try:
        pattern = re.compile(regex, re.IGNORECASE)
        books = Book.objects.all()
        matched_books = [book for book in books if pattern.search(book.title)]
    except re.error:
        return JsonResponse({"error": "Expression régulière invalide"}, status=400)

    if matched_books:
        data = [{"title": b.title, "author": b.author} for b in matched_books]
        return JsonResponse(data, safe=False)

    return JsonResponse({"error": "Aucun livre trouvé"}, status=404)"""

""" ----------------- Classement des livres avec PageRank -----------------"""

def rank_books(request):
    books = Book.objects.all()
    G = nx.Graph()

    for book in books:
        G.add_node(book.title, download_count=book.download_count)

    for book1 in books:
        for book2 in books:
            if book1.author == book2.author and book1.title != book2.title:
                G.add_edge(book1.title, book2.title)

    pagerank = nx.pagerank(G)
    ranked_books = sorted(books, key=lambda b: pagerank.get(b.title, 0), reverse=True)

    data = [{"title": b.title, "author": b.author, "score": pagerank.get(b.title, 0)} for b in ranked_books]
    return JsonResponse(data, safe=False)

""" ------------------ Suggestion basée sur la similarité de Jaccard -------------------- """

def suggest_books(request):
    books = Book.objects.all()
    G = nx.Graph()

    for book in books:
        G.add_node(book.title)

    for book1 in books:
        for book2 in books:
            if book1.author == book2.author and book1.title != book2.title:
                G.add_edge(book1.title, book2.title)

    suggestions = {}
    for book in books:
        neighbors = list(G.neighbors(book.title))
        suggestions[book.title] = neighbors

    return JsonResponse(suggestions, safe=False)


from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('api.urls')),
    path('', include('api.urls')),
]

from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=255)
    author = models.CharField(max_length=255, blank=True, null=True)
    language = models.CharField(max_length=10)
    download_count = models.IntegerField(default=0)
    cover_url = models.URLField(blank=True, null=True)
    word_count = models.IntegerField(default=0) #termes count
    content = models.TextField(blank=True) #contenu du livre

    def __str__(self):
        return self.title

class Term(models.Model):
    """术语模型 - 存储单个词汇"""
    word = models.CharField(max_length=100, unique=True)
    document_count = models.IntegerField(default=0)  # 包含该词的文档数量(用于IDF计算)

    def __str__(self):
        return self.word

class TermDocumentIndex(models.Model):
    """词-文档索引模型 - 存储TF-IDF权重"""
    term = models.ForeignKey(Term, on_delete=models.CASCADE)
    document = models.ForeignKey(Book, on_delete=models.CASCADE)
    tf = models.FloatField(default=0.0)  # 词频
    tfidf = models.FloatField(default=0.0)  # TF-IDF权重

    class Meta:
        # 确保每个词-文档对只有一个记录
        unique_together = ('term', 'document')
        # 添加索引提高查询性能
        indexes = [
            models.Index(fields=['term']),
            models.Index(fields=['document']),
        ]


这是https://gutendex.com/books/id的api的输出格式{

  "id": 26184,

  "title": "Simple Sabotage Field Manual",

  "authors": [

    {

      "name": "United States. Office of Strategic Services",

      "birth_year": null,

      "death_year": null

    }

  ],

  "summaries": [

    "\"Simple Sabotage Field Manual\" by United States. Office of Strategic Services is a historical publication written during the early 1940s, amid World War II. This manual acts as a guide for ordinary civilians to conduct simple acts of sabotage against enemy operations without the need for specialized training or equipment. Its main topic revolves around promoting small, accessible forms of resistance that could collectively disrupt the enemy's war effort.  The manual outlines various strategies and techniques for citizens to engage in sabotage that could be executed discreetly and with minimal risk. It provides specific suggestions for targeting transportation, communication, and industrial facilities to create delays and inefficiencies in enemy operations. The manual emphasizes the power of many individuals acting independently to contribute to a larger campaign of disruption, encouraging simple acts such as misplacing tools, delaying communication, or damaging equipment with household items. Overall, the \"Simple Sabotage Field Manual\" serves as a unique historical artifact that illustrates grassroots resistance efforts and the belief in the collective power of ordinary people during wartime. (This is an automatically generated summary.)"

  ],

  "translators": [],

  "subjects": [

    "Sabotage"

  ],

  "bookshelves": [

    "Browsing: History - Warfare"

  ],

  "languages": [

    "en"

  ],

  "copyright": false,

  "media_type": "Text",

  "formats": {

    "text/html": "https://www.gutenberg.org/ebooks/26184.html.images",

    "application/epub+zip": "https://www.gutenberg.org/ebooks/26184.epub3.images",

    "application/x-mobipocket-ebook": "https://www.gutenberg.org/ebooks/26184.kf8.images",

    "text/plain; charset=us-ascii": "https://www.gutenberg.org/ebooks/26184.txt.utf-8",

    "application/rdf+xml": "https://www.gutenberg.org/ebooks/26184.rdf",

    "image/jpeg": "https://www.gutenberg.org/cache/epub/26184/pg26184.cover.medium.jpg",

    "application/octet-stream": "https://www.gutenberg.org/cache/epub/26184/pg26184-h.zip"

  },

  "download_count": 205449

}

这是https://gutendex.com/books的实例:



{
  "count": 75510,
  "next": "https://gutendex.com/books/?page=2",
  "previous": null,
  "results": [
    {
      "id": 26184,
      "title": "Simple Sabotage Field Manual",
      "authors": [
        {
          "name": "United States. Office of Strategic Services",
          "birth_year": null,
          "death_year": null
        }
      ],
      "summaries": [
        "\"Simple Sabotage Field Manual\" by United States. Office of Strategic Services is a historical publication written during the early 1940s, amid World War II. This manual acts as a guide for ordinary civilians to conduct simple acts of sabotage against enemy operations without the need for specialized training or equipment. Its main topic revolves around promoting small, accessible forms of resistance that could collectively disrupt the enemy's war effort.  The manual outlines various strategies and techniques for citizens to engage in sabotage that could be executed discreetly and with minimal risk. It provides specific suggestions for targeting transportation, communication, and industrial facilities to create delays and inefficiencies in enemy operations. The manual emphasizes the power of many individuals acting independently to contribute to a larger campaign of disruption, encouraging simple acts such as misplacing tools, delaying communication, or damaging equipment with household items. Overall, the \"Simple Sabotage Field Manual\" serves as a unique historical artifact that illustrates grassroots resistance efforts and the belief in the collective power of ordinary people during wartime. (This is an automatically generated summary.)"
      ],
      "translators": [],
      "subjects": [
        "Sabotage"
      ],
      "bookshelves": [
        "Browsing: History - Warfare"
      ],
      "languages": [
        "en"
      ],
      "copyright": false,
      "media_type": "Text",
      "formats": {
        "text/html": "https://www.gutenberg.org/ebooks/26184.html.images",
        "application/epub+zip": "https://www.gutenberg.org/ebooks/26184.epub3.images",
        "application/x-mobipocket-ebook": "https://www.gutenberg.org/ebooks/26184.kf8.images",
        "text/plain; charset=us-ascii": "https://www.gutenberg.org/ebooks/26184.txt.utf-8",
        "application/rdf+xml": "https://www.gutenberg.org/ebooks/26184.rdf",
        "image/jpeg": "https://www.gutenberg.org/cache/epub/26184/pg26184.cover.medium.jpg",
        "application/octet-stream": "https://www.gutenberg.org/cache/epub/26184/pg26184-h.zip"
      },
      "download_count": 205449
    },
    {
      "id": 84,
      "title": "Frankenstein; Or, The Modern Prometheus",
      "authors": [
        {
          "name": "Shelley, Mary Wollstonecraft",
          "birth_year": 1797,
          "death_year": 1851
        }
      ],
      "summaries": [
        "\"Frankenstein; Or, The Modern Prometheus\" by Mary Wollstonecraft Shelley is a novel written in the early 19th century. The story explores themes of ambition, the quest for knowledge, and the consequences of man's hubris through the experiences of Victor Frankenstein and the monstrous creation of his own making.   The opening of the book introduces Robert Walton, an ambitious explorer on a quest to discover new lands and knowledge in the icy regions of the Arctic. In his letters to his sister Margaret, he expresses both enthusiasm and the fear of isolation in his grand venture. As Walton's expedition progresses, he encounters a mysterious, emaciated stranger who has faced great suffering—furthering the intrigue of his narrative. This stranger ultimately reveals his tale of creation, loss, and the profound consequences of seeking knowledge that lies beyond human bounds. The narrative is set up in a manner that suggests a deep examination of the emotions and ethical dilemmas faced by those who dare to defy the natural order. (This is an automatically generated summary.)"
      ],
      "translators": [],
      "subjects": [
        "Frankenstein's monster (Fictitious character) -- Fiction",
        "Frankenstein, Victor (Fictitious character) -- Fiction",
        "Gothic fiction",
        "Horror tales",
        "Monsters -- Fiction",
        "Science fiction",
        "Scientists -- Fiction"
      ],
      "bookshelves": [
        "Browsing: Culture/Civilization/Society",
        "Browsing: Fiction",
        "Browsing: Gender & Sexuality Studies",
        "Browsing: Literature",
        "Browsing: Science-Fiction & Fantasy",
        "Gothic Fiction",
        "Movie Books",
        "Precursors of Science Fiction",
        "Science Fiction by Women"
      ],
      "languages": [
        "en"
      ],
      "copyright": false,
      "media_type": "Text",
      "formats": {
        "text/html": "https://www.gutenberg.org/ebooks/84.html.images",
        "application/epub+zip": "https://www.gutenberg.org/ebooks/84.epub3.images",
        "application/x-mobipocket-ebook": "https://www.gutenberg.org/ebooks/84.kf8.images",
        "application/rdf+xml": "https://www.gutenberg.org/ebooks/84.rdf",
        "image/jpeg": "https://www.gutenberg.org/cache/epub/84/pg84.cover.medium.jpg",
        "text/plain; charset=us-ascii": "https://www.gutenberg.org/ebooks/84.txt.utf-8",
        "application/octet-stream": "https://www.gutenberg.org/cache/epub/84/pg84-h.zip"
      },
      "download_count": 146616
    },
    
    

获取书的字数的方式应该是访问


 "formats": {
        "text/html": "https://www.gutenberg.org/ebooks/2701.html.images",这一段里的url，里面是书的完整内容
